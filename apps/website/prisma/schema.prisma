// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = []
}

datasource db {
  provider          = "mysql"
  relationMode      = "prisma"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model ClientAccessToken {
  service       String
  client_id     String
  access_token  String
  refresh_token String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  expiresAt     DateTime?

  @@unique([service, client_id])
}

model TaskExecutionEvent {
  id         String   @id @default(cuid())
  task       String
  startedAt  DateTime @default(now())
  finishedAt DateTime
}

model ChannelUpdateEvent {
  id            String   @id @default(cuid())
  service       String
  channel       String
  title         String
  category_id   String
  category_name String
  source        String
  createdAt     DateTime @default(now())
}

model StreamStatusEvent {
  id        String    @id @default(cuid())
  service   String
  channel   String
  online    Boolean
  source    String
  createdAt DateTime  @default(now())
  startedAt DateTime?
}

// Necessary for Next auth
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  twitchChannelBroadcaster TwitchChannel[] @relation("BroadcasterAccount")
  twitchChannelModerator   TwitchChannel[] @relation("ModeratorAccount")

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                 String             @id @default(cuid())
  name               String?
  email              String?            @unique
  emailVerified      DateTime?
  image              String?
  accounts           Account[]
  sessions           Session[]
  pushSubscriptions  PushSubscription[]
  notificationPushes NotificationPush[]
  GiveawayEntry      GiveawayEntry[]
  OutgoingWebhook    OutgoingWebhook[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Notification {
  id          String                 @id @default(cuid())
  message     String
  ttl         Int
  title       String?
  linkUrl     String?
  imageUrl    String?
  callapseId  String?
  scheduledAt DateTime?
  topic       String?
  categories  NotificationCategory[]
  pushes      NotificationPush[]
}

model NotificationCategory {
  notificationId String
  name           String
  notification   Notification @relation(fields: [notificationId], references: [id])

  @@unique([notificationId, name])
}

model NotificationPush {
  notificationId String
  subscriptionId String
  userId         String?
  attempts       Int?
  clickedAt      DateTime?
  failedAt       DateTime?
  deliveredAt    DateTime?
  user           User?            @relation(fields: [userId], references: [id])
  notification   Notification     @relation(fields: [notificationId], references: [id])
  subscription   PushSubscription @relation(fields: [subscriptionId], references: [id])

  @@unique([notificationId, subscriptionId])
}

// FIXME: Endpoint URLs could be up to 2048 chars, which would be 8192 bytes with utf8mb4 (4 bytes per char),
//        but innodb unique index keys may only be up to 3072 bytes which would be 768 characters so we round
//        down to 720. So far Endpoint URLS have been less than 256 chars. So that _should_ not collide.
model PushSubscription {
  id        String                @id @default(cuid())
  userId    String?
  endpoint  String                @db.VarChar(720) // ^ see FIXME above
  p256dh    String?
  auth      String?
  createdAt DateTime              @default(now())
  updatedAt DateTime              @updatedAt
  user      User?                 @relation(fields: [userId], references: [id])
  tags      PushSubscriptionTag[]
  pushes    NotificationPush[]

  @@unique([endpoint])
}

model PushSubscriptionTag {
  subscriptionId String
  name           String
  value          String
  subscription   PushSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@unique([subscriptionId, name])
}

model MailingAddress {
  id           String @id @default(cuid())
  country      String
  addressLine1 String
  addressLine2 String
  city         String
  state        String
  postalCode   String

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  giveawayEntry GiveawayEntry?
}

model Giveaway {
  id                 String    @id @default(cuid())
  label              String
  slug               String?
  active             Boolean   @default(false)
  startAt            DateTime  @default(now())
  endAt              DateTime?
  outgoingWebhookUrl String?   @db.VarChar(720)
  showInLists        Boolean   @default(true)
  config             String    @default("") @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  entries GiveawayEntry[]
}

model GiveawayEntry {
  id                String  @id @default(cuid())
  giveawayId        String
  userId            String
  mailingAddressId  String  @unique
  outgoingWebhookId String? @unique
  email             String?
  givenName         String
  familyName        String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  giveaway        Giveaway         @relation(fields: [giveawayId], references: [id])
  user            User             @relation(fields: [userId], references: [id])
  mailingAddress  MailingAddress   @relation(fields: [mailingAddressId], references: [id])
  outgoingWebhook OutgoingWebhook? @relation(fields: [outgoingWebhookId], references: [id])

  @@unique([giveawayId, userId])
}

model OutgoingWebhook {
  id          String    @id @default(cuid())
  type        String
  url         String    @db.VarChar(720)
  body        String    @db.Text
  userId      String?
  attempts    Int?
  createdAt   DateTime  @default(now())
  failedAt    DateTime?
  deliveredAt DateTime?

  user          User?          @relation(fields: [userId], references: [id])
  giveawayEntry GiveawayEntry?
}

model TwitchChannel {
  channelId            String  @id
  username             String
  label                String
  broadcasterAccountId String?
  moderatorAccountId   String?

  broadcasterAccount Account? @relation(name: "BroadcasterAccount", fields: [broadcasterAccountId], references: [id])
  moderatorAccount   Account? @relation(name: "ModeratorAccount", fields: [moderatorAccountId], references: [id])
}
